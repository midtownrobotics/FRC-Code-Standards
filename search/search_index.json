{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FRC 1648 Code Standards This repository is the definitive guide for all team members, outlining the coding conventions and best practices to follow when developing software for our robotics projects. Consistency, readability, and maintainability are key to sustaining a high-quality codebase. These guidelines have been crafted to ensure that every contributor follows a unified approach, helping us build reliable, efficient, and scalable systems. Purpose This repository defines the coding standards and best practices that guide our team\u2019s software development process. The purpose is to ensure that our codebase remains clear, maintainable, and scalable while promoting collaboration and technical excellence. These guidelines serve not only as rules but as a foundation for building high-quality robotics software that every team member can confidently contribute to. By following these practices, we aim to: Improve Code Clarity: Write code that is easy to read, understand, and modify, making it accessible to all team members, regardless of experience. Support Collaboration: Create a cohesive development environment by establishing uniform coding conventions, enabling smoother teamwork and onboarding of new developers. Ensure Maintainability: Build a robust codebase that can be easily maintained and extended, ensuring the longevity of our projects across seasons. Boost Efficiency and Reliability: Reduce bugs and development time by using proven, standardized approaches for coding, testing, and debugging. Foster Innovation and Excellence: Encourage a culture of continual learning, improvement, and technical mastery by adhering to professional-level coding standards. Ensure Safety and Robustness: Implement safeguards in code to protect against failures or unforeseen issues, ensuring the safety and reliability of our robots in competition and testing. Table of Contents Global Standards Filesystem Standards Constants Standards Logging Standards AdvantageKit Standards Subsystem Standards Command Standards Control Loop Standards RobotState.java Standards","title":"FRC 1648 Code Standards"},{"location":"#frc-1648-code-standards","text":"This repository is the definitive guide for all team members, outlining the coding conventions and best practices to follow when developing software for our robotics projects. Consistency, readability, and maintainability are key to sustaining a high-quality codebase. These guidelines have been crafted to ensure that every contributor follows a unified approach, helping us build reliable, efficient, and scalable systems.","title":"FRC 1648 Code Standards"},{"location":"#purpose","text":"This repository defines the coding standards and best practices that guide our team\u2019s software development process. The purpose is to ensure that our codebase remains clear, maintainable, and scalable while promoting collaboration and technical excellence. These guidelines serve not only as rules but as a foundation for building high-quality robotics software that every team member can confidently contribute to. By following these practices, we aim to: Improve Code Clarity: Write code that is easy to read, understand, and modify, making it accessible to all team members, regardless of experience. Support Collaboration: Create a cohesive development environment by establishing uniform coding conventions, enabling smoother teamwork and onboarding of new developers. Ensure Maintainability: Build a robust codebase that can be easily maintained and extended, ensuring the longevity of our projects across seasons. Boost Efficiency and Reliability: Reduce bugs and development time by using proven, standardized approaches for coding, testing, and debugging. Foster Innovation and Excellence: Encourage a culture of continual learning, improvement, and technical mastery by adhering to professional-level coding standards. Ensure Safety and Robustness: Implement safeguards in code to protect against failures or unforeseen issues, ensuring the safety and reliability of our robots in competition and testing.","title":"Purpose"},{"location":"#table-of-contents","text":"Global Standards Filesystem Standards Constants Standards Logging Standards AdvantageKit Standards Subsystem Standards Command Standards Control Loop Standards RobotState.java Standards","title":"Table of Contents"},{"location":"advantagekit-standards/","text":"AdvantageKit Standards This section provides standards that govern the IO inputs and implementations in robot projects. IO Interfaces and Inputs A subsystem's IO interface is what defines the inputs that are automatically logged for that subsystem. It is important to log any information that could be useful in Log Replay , because any information that is not logged as an input can't be used to create new simulated outputs. The fields that 1648 logs in every subsystem's IO interface depends on the hardware used in that subsystem: Motors: Position ( Rotation2d ) Velocity (Radians/Second) Applied Voltage (Volts) Supply Current (Amps) Stator Current (Amps) Temperature (Fahrenheit) Pneumatic Actuators: Position (boolean, true if extended, false if retracted) This is not a comprehensive list, rather a starting point for input logging that will be sufficient for most subsystems. Every IO interface must have a static Inputs class where all the inputs are defined and instantiated with default values. The @AutoLog annotation must be used to tell the robot code that the fields in the inputs class are to be logged. Every IO interface must also have a default updateInputs method, updates the inputs for the subsystem every loop cycle. package frc.robot.subsystems.intake; import org.littletonrobotics.junction.AutoLog; public interface IntakeIO { @AutoLog public static class IntakeIOInputs { public Rotation2d rollersPosition = Rotation2d.fromRadians(0.0); public double rollersVelocityRadPerSec = 0.0; public double rollersAppliedVolts = 0.0; public double rollersSupplyCurrentAmps = 0.0; public double rollersStatorCurrentAmps = 0.0; public double rollersTempCelcius = 0.0; public boolean leftPosition = false; public boolean rightPosition = false; } public default void updateInputs(IntakeIOInputs inputs) {} public default void setRollersVoltage(double volts) {} public default void setIntakePosition(boolean isDeployed) {} } IO Implementations In FRC, it is often useful to abstract a subsystem's hardware away from its logic. This is useful for running multiple robots with different hardware using the same code. For example, a practice robot may be running one type of motor, whereas the competition robot may run a different type of motor. In order to run the same code on both robots, hardware abstraction is used to keep the logic the same for both robots, while switching between hardware. This is done through the use of IO implementations. IO implementations are where actual hardware behaviors are defined. Each IO implementation must: - Implement its subsystem IO interface. - Override updateInputs() for specific hardware updates. - Implement hardware specific actuation. package frc.robot.subsystems.intake; import com.ctre.phoenix6.BaseStatusSignal; import com.ctre.phoenix6.StatusSignal; import com.ctre.phoenix6.configs.TalonFXConfiguration; import com.ctre.phoenix6.controls.VoltageOut; import com.ctre.phoenix6.hardware.TalonFX; import com.ctre.phoenix6.signals.InvertedValue; import edu.wpi.first.math.geometry.Rotation2d; import edu.wpi.first.math.util.Units; import edu.wpi.first.wpilibj.PneumaticsModuleType; import edu.wpi.first.wpilibj.Solenoid; import frc.robot.util.Alert; import frc.robot.util.Alert.AlertType; public class IntakeIOTalonFX implements IntakeIO { private final TalonFX rollersTalon; private final Solenoid solenoid; private final StatusSignal<Double> rollersPosition; private final StatusSignal<Double> rollersVelocity; private final StatusSignal<Double> rollersAppliedVolts; private final StatusSignal<Double> rollersSupplyCurrent; private final StatusSignal<Double> rollersStatorCurrent; private final StatusSignal<Double> rollersTemperature; private final Alert rollersDisconnectedAlert = new Alert(\"Rollers Talon is disconnected, check CAN bus.\", AlertType.ERROR); public IntakeIOTalonFX() { rollersTalon = new TalonFX(IntakeConstants.DEVICE_ID); solenoid = new Solenoid(PneumaticsModuleType.CTREPCM, IntakeConstants.SOLENOID_CHANNEL); var config = new TalonFXConfiguration(); config.CurrentLimits.SupplyCurrentLimit = IntakeConstants.SUPPLY_CURRENT_LIMIT; config.CurrentLimits.SupplyCurrentLimitEnable = true; config.MotorOutput.Inverted = InvertedValue.Clockwise_Positive; config.Audio.AllowMusicDurDisable = true; config.Audio.BeepOnBoot = false; config.Audio.BeepOnConfig = false; rollersTalon.getConfigurator().apply(config); rollersPosition = rollersTalon.getPosition(); rollersVelocity = rollersTalon.getVelocity(); rollersAppliedVolts = rollersTalon.getMotorVoltage(); rollersSupplyCurrent = rollersTalon.getSupplyCurrent(); rollersStatorCurrent = rollersTalon.getStatorCurrent(); rollersTemperature = rollersTalon.getDeviceTemp(); BaseStatusSignal.setUpdateFrequencyForAll(100.0, rollersVelocity); BaseStatusSignal.setUpdateFrequencyForAll( 50.0, rollersPosition, rollersAppliedVolts, rollersSupplyCurrent, rollersStatorCurrent, rollersTemperature); rollersTalon.optimizeBusUtilization(); } @Override public void updateInputs(IntakeIOInputs inputs) { boolean rollersConnected = BaseStatusSignal.refreshAll( rollersVelocity, rollersPosition, rollersAppliedVolts, rollersSupplyCurrent, rollersStatorCurrent, rollersTemperature) .isOK(); rollersDisconnectedAlert.set(!rollersConnected); inputs.rollersPositionRad = Rotation2d.fromRadians(Units.rotationsToRadians(rollersPosition.getValueAsDouble()) / IntakeConstants.GEAR_RATIO); inputs.rollersVelocityRadPerSec = Units.rotationsToRadians(rollersVelocity.getValueAsDouble()) / IntakeConstants.GEAR_RATIO; inputs.rollersAppliedVolts = rollersAppliedVolts.getValueAsDouble(); inputs.rollersSupplyCurrentAmps = rollersSupplyCurrent.getValueAsDouble(); inputs.rollersStatorCurrentAmps = rollersStatorCurrent.getValueAsDouble(); inputs.rollersTempCelcius = rollersTemperature.getValueAsDouble(); inputs.leftPosition = solenoid.get(); } @Override public void setRollersVoltage(double volts) { rollersTalon.setControl(new VoltageOut(volts)); } @Override public void setIntakePosition(boolean position) { solenoid.set(position); } } Simulated IO Implementations IO implementations can also be physics simulators. Instead of having simulation code in the subsystem, an IO implementation can be written and instantiated when running the robot code in simulation. package frc.robot.subsystems.intake; import edu.wpi.first.math.MathUtil; import edu.wpi.first.math.geometry.Rotation2d; import edu.wpi.first.wpilibj.simulation.DCMotorSim; import frc.robot.Constants; public class IntakeIOSim implements IntakeIO { private DCMotorSim motorSim = new DCMotorSim( IntakeConstants.MOTOR_CONFIG, IntakeConstants.GEAR_RATIO, IntakeConstants.MOMENT_OF_INERTIA); private double rollersAppliedVolts = 0.0; private boolean leftPosition = false; private boolean rightPosition = false; @Override public void updateInputs(IntakeIOInputs inputs) { motorSim.update(Constants.LOOP_PERIOD_SECS); inputs.rollersPositionRad = Rotation2d.fromRadians(motorSim.getAngularPositionRad()); inputs.rollersVelocityRadPerSec = motorSim.getAngularVelocityRadPerSec(); inputs.rollersAppliedVolts = rollersAppliedVolts; inputs.rollersSupplyCurrentAmps = Math.abs(motorSim.getCurrentDrawAmps()); inputs.rollersTempCelcius = 0.0; inputs.leftPosition = leftPosition; inputs.rightPosition = rightPosition; } @Override public void setRollersVoltage(double volts) { rollersAppliedVolts = MathUtil.clamp(volts, -12.0, 12.0); motorSim.setInputVoltage(rollersAppliedVolts); } @Override public void setIntakePosition(boolean position) { leftPosition = position; rightPosition = position; } }","title":"Advantagekit Standards"},{"location":"advantagekit-standards/#advantagekit-standards","text":"This section provides standards that govern the IO inputs and implementations in robot projects.","title":"AdvantageKit Standards"},{"location":"advantagekit-standards/#io-interfaces-and-inputs","text":"A subsystem's IO interface is what defines the inputs that are automatically logged for that subsystem. It is important to log any information that could be useful in Log Replay , because any information that is not logged as an input can't be used to create new simulated outputs. The fields that 1648 logs in every subsystem's IO interface depends on the hardware used in that subsystem: Motors: Position ( Rotation2d ) Velocity (Radians/Second) Applied Voltage (Volts) Supply Current (Amps) Stator Current (Amps) Temperature (Fahrenheit) Pneumatic Actuators: Position (boolean, true if extended, false if retracted) This is not a comprehensive list, rather a starting point for input logging that will be sufficient for most subsystems. Every IO interface must have a static Inputs class where all the inputs are defined and instantiated with default values. The @AutoLog annotation must be used to tell the robot code that the fields in the inputs class are to be logged. Every IO interface must also have a default updateInputs method, updates the inputs for the subsystem every loop cycle. package frc.robot.subsystems.intake; import org.littletonrobotics.junction.AutoLog; public interface IntakeIO { @AutoLog public static class IntakeIOInputs { public Rotation2d rollersPosition = Rotation2d.fromRadians(0.0); public double rollersVelocityRadPerSec = 0.0; public double rollersAppliedVolts = 0.0; public double rollersSupplyCurrentAmps = 0.0; public double rollersStatorCurrentAmps = 0.0; public double rollersTempCelcius = 0.0; public boolean leftPosition = false; public boolean rightPosition = false; } public default void updateInputs(IntakeIOInputs inputs) {} public default void setRollersVoltage(double volts) {} public default void setIntakePosition(boolean isDeployed) {} }","title":"IO Interfaces and Inputs"},{"location":"advantagekit-standards/#io-implementations","text":"In FRC, it is often useful to abstract a subsystem's hardware away from its logic. This is useful for running multiple robots with different hardware using the same code. For example, a practice robot may be running one type of motor, whereas the competition robot may run a different type of motor. In order to run the same code on both robots, hardware abstraction is used to keep the logic the same for both robots, while switching between hardware. This is done through the use of IO implementations. IO implementations are where actual hardware behaviors are defined. Each IO implementation must: - Implement its subsystem IO interface. - Override updateInputs() for specific hardware updates. - Implement hardware specific actuation. package frc.robot.subsystems.intake; import com.ctre.phoenix6.BaseStatusSignal; import com.ctre.phoenix6.StatusSignal; import com.ctre.phoenix6.configs.TalonFXConfiguration; import com.ctre.phoenix6.controls.VoltageOut; import com.ctre.phoenix6.hardware.TalonFX; import com.ctre.phoenix6.signals.InvertedValue; import edu.wpi.first.math.geometry.Rotation2d; import edu.wpi.first.math.util.Units; import edu.wpi.first.wpilibj.PneumaticsModuleType; import edu.wpi.first.wpilibj.Solenoid; import frc.robot.util.Alert; import frc.robot.util.Alert.AlertType; public class IntakeIOTalonFX implements IntakeIO { private final TalonFX rollersTalon; private final Solenoid solenoid; private final StatusSignal<Double> rollersPosition; private final StatusSignal<Double> rollersVelocity; private final StatusSignal<Double> rollersAppliedVolts; private final StatusSignal<Double> rollersSupplyCurrent; private final StatusSignal<Double> rollersStatorCurrent; private final StatusSignal<Double> rollersTemperature; private final Alert rollersDisconnectedAlert = new Alert(\"Rollers Talon is disconnected, check CAN bus.\", AlertType.ERROR); public IntakeIOTalonFX() { rollersTalon = new TalonFX(IntakeConstants.DEVICE_ID); solenoid = new Solenoid(PneumaticsModuleType.CTREPCM, IntakeConstants.SOLENOID_CHANNEL); var config = new TalonFXConfiguration(); config.CurrentLimits.SupplyCurrentLimit = IntakeConstants.SUPPLY_CURRENT_LIMIT; config.CurrentLimits.SupplyCurrentLimitEnable = true; config.MotorOutput.Inverted = InvertedValue.Clockwise_Positive; config.Audio.AllowMusicDurDisable = true; config.Audio.BeepOnBoot = false; config.Audio.BeepOnConfig = false; rollersTalon.getConfigurator().apply(config); rollersPosition = rollersTalon.getPosition(); rollersVelocity = rollersTalon.getVelocity(); rollersAppliedVolts = rollersTalon.getMotorVoltage(); rollersSupplyCurrent = rollersTalon.getSupplyCurrent(); rollersStatorCurrent = rollersTalon.getStatorCurrent(); rollersTemperature = rollersTalon.getDeviceTemp(); BaseStatusSignal.setUpdateFrequencyForAll(100.0, rollersVelocity); BaseStatusSignal.setUpdateFrequencyForAll( 50.0, rollersPosition, rollersAppliedVolts, rollersSupplyCurrent, rollersStatorCurrent, rollersTemperature); rollersTalon.optimizeBusUtilization(); } @Override public void updateInputs(IntakeIOInputs inputs) { boolean rollersConnected = BaseStatusSignal.refreshAll( rollersVelocity, rollersPosition, rollersAppliedVolts, rollersSupplyCurrent, rollersStatorCurrent, rollersTemperature) .isOK(); rollersDisconnectedAlert.set(!rollersConnected); inputs.rollersPositionRad = Rotation2d.fromRadians(Units.rotationsToRadians(rollersPosition.getValueAsDouble()) / IntakeConstants.GEAR_RATIO); inputs.rollersVelocityRadPerSec = Units.rotationsToRadians(rollersVelocity.getValueAsDouble()) / IntakeConstants.GEAR_RATIO; inputs.rollersAppliedVolts = rollersAppliedVolts.getValueAsDouble(); inputs.rollersSupplyCurrentAmps = rollersSupplyCurrent.getValueAsDouble(); inputs.rollersStatorCurrentAmps = rollersStatorCurrent.getValueAsDouble(); inputs.rollersTempCelcius = rollersTemperature.getValueAsDouble(); inputs.leftPosition = solenoid.get(); } @Override public void setRollersVoltage(double volts) { rollersTalon.setControl(new VoltageOut(volts)); } @Override public void setIntakePosition(boolean position) { solenoid.set(position); } }","title":"IO Implementations"},{"location":"advantagekit-standards/#simulated-io-implementations","text":"IO implementations can also be physics simulators. Instead of having simulation code in the subsystem, an IO implementation can be written and instantiated when running the robot code in simulation. package frc.robot.subsystems.intake; import edu.wpi.first.math.MathUtil; import edu.wpi.first.math.geometry.Rotation2d; import edu.wpi.first.wpilibj.simulation.DCMotorSim; import frc.robot.Constants; public class IntakeIOSim implements IntakeIO { private DCMotorSim motorSim = new DCMotorSim( IntakeConstants.MOTOR_CONFIG, IntakeConstants.GEAR_RATIO, IntakeConstants.MOMENT_OF_INERTIA); private double rollersAppliedVolts = 0.0; private boolean leftPosition = false; private boolean rightPosition = false; @Override public void updateInputs(IntakeIOInputs inputs) { motorSim.update(Constants.LOOP_PERIOD_SECS); inputs.rollersPositionRad = Rotation2d.fromRadians(motorSim.getAngularPositionRad()); inputs.rollersVelocityRadPerSec = motorSim.getAngularVelocityRadPerSec(); inputs.rollersAppliedVolts = rollersAppliedVolts; inputs.rollersSupplyCurrentAmps = Math.abs(motorSim.getCurrentDrawAmps()); inputs.rollersTempCelcius = 0.0; inputs.leftPosition = leftPosition; inputs.rightPosition = rightPosition; } @Override public void setRollersVoltage(double volts) { rollersAppliedVolts = MathUtil.clamp(volts, -12.0, 12.0); motorSim.setInputVoltage(rollersAppliedVolts); } @Override public void setIntakePosition(boolean position) { leftPosition = position; rightPosition = position; } }","title":"Simulated IO Implementations"},{"location":"commands-standards/","text":"Command Standards This section provides standards that govern the Commands and autonomous routines in robot projects. Subsystem Commands In order for a subsystem to be useful, they must be told to do something, this is what commands are for. Subsystems tell the actuators how to do something (ex. run at a voltage, follow a motion profile, account for feedback, etc.) while commands tell the robot to actually execute the tasks. Simple commands that only require one subsystem are located in that subsystem. public Command runVelocity() { return runEnd( () -> { setSpinVelocity(ShooterConstants.DEFAULT_SPEED.get()); }, () -> { stop(); }); } These commands can be used in other places in the robot code by referencing the subsystem. ex. shooter.runVelocity(); Subsystem Command Exceptions In long and complicated subsystems that have a lot of logic, it can be useful to separate commands into a different class to improve code readibility. Composite Commands Composite commands are commands that are made up of more than one pre-defined command. They always take the form of a static factory. In general, composite commands should never be their own classes. WPIlib has excellent documentation on Command Composition as well as Command Decorators which are much more intuitive and concise. It is generally best to write commands as compositions rather than string commands together with decorators. ex. public static final Command getCollectCommand(Intake intake, Serializer serializer) { return Commands.sequence( intake.deployIntake(), Commands.race(intake.runVoltage(), serializer.intake()), intake.retractIntake()); } instead of public static final Command getCollectCommand(Intake intake, Serializer serializer) { return intake.deployIntake() .andThen(Commands.race(intake.runVoltage(), serializer.intake())) .andThen(intake.retractIntake()); } Composite commands reside in their own class called CompositeCommands.java . Button Bindings and Triggers Commands tell the robot to execute tasks, but in order for the robot code to schedule the command for execution, it needs to be bound to a Trigger . Triggers tell the robot which conditions need to be met to execute commands. Triggers are always instantiated in the configureButtonBindings() method of RobotContainer.java . driver .rightBumper() .and(() -> RobotState.shooterReady(hood, shooter)) .whileTrue( Commands.waitSeconds(0.25) .andThen(CompositeCommands.getShootCommand(intake, serializer, kicker))); in this case, rightBumper() is the trigger representing the right bumper button on the driver's Xbox 360 controller. The .and() call adds another condition to the trigger. The .whileTrue() call means that the robot trigger will only run the command while the conditions of the trigger are met. This trigger made the robot only able to shoot when the driver pressed the right bumper and when the robot code reported the shooter was ready to fire. It is worth noting that Triggers can be arbitrary by creating a new Trigger object and binding it to an event, which can then be passed into a command as a parameter. ex. Trigger arbitraryTrigger = new Trigger(limitSwitch::get) However, this usually isn't necessary because required subsystems get passed into composite commands, meaning there usually isn't a reason to bind command to a trigger unless it's being bound to a button. Arbitrary Triggers are most useful when a condition must be met across a wide number of commands. Trigger shooterReady = new Trigger(() -> RobotState.shooterReady(hood, shooter)) driver .rightBumper() .and(shooterReady) .whileTrue( Commands.waitSeconds(0.25) .andThen(CompositeCommands.getShootCommand(intake, serializer, kicker))); Autonomous Routines Autonomous routines are simply composite command that are called during autonomous. Autonomous paths are loaded into the roborio when the code is deployed, and called during the autonomous period. We can follow a path using its path on the roborio. public static final Command centerTwoPiece( Drive drive, Intake intake, Serializer serializer, Kicker kicker, TrackingMode targetType) { return Commands.sequence( AutoBuilder.followPath(PathPlannerPath.fromPathFile(\"deploy/paths/Center to Center Wing Note\")), CompositeCommands.getAimSpeakerCommand(drive), CompositeCommands.getShootCommand(intake, serializer, kicker), CompositeCommands.getTrackNoteSpikeCommand( drive, intake, serializer, AutoPathPoints.NOTE_2, targetType), CompositeCommands.getAimSpeakerCommand(drive), CompositeCommands.getShootCommand(intake, serializer, kicker)); } Ankit notes: - Separate out factories 254 style. - Do we use PathPlanner autos or make the commands in code? PathPlanner autos are visually nicer but can't take arguments","title":"Command Standards"},{"location":"commands-standards/#command-standards","text":"This section provides standards that govern the Commands and autonomous routines in robot projects.","title":"Command Standards"},{"location":"commands-standards/#subsystem-commands","text":"In order for a subsystem to be useful, they must be told to do something, this is what commands are for. Subsystems tell the actuators how to do something (ex. run at a voltage, follow a motion profile, account for feedback, etc.) while commands tell the robot to actually execute the tasks. Simple commands that only require one subsystem are located in that subsystem. public Command runVelocity() { return runEnd( () -> { setSpinVelocity(ShooterConstants.DEFAULT_SPEED.get()); }, () -> { stop(); }); } These commands can be used in other places in the robot code by referencing the subsystem. ex. shooter.runVelocity();","title":"Subsystem Commands"},{"location":"commands-standards/#subsystem-command-exceptions","text":"In long and complicated subsystems that have a lot of logic, it can be useful to separate commands into a different class to improve code readibility.","title":"Subsystem Command Exceptions"},{"location":"commands-standards/#composite-commands","text":"Composite commands are commands that are made up of more than one pre-defined command. They always take the form of a static factory. In general, composite commands should never be their own classes. WPIlib has excellent documentation on Command Composition as well as Command Decorators which are much more intuitive and concise. It is generally best to write commands as compositions rather than string commands together with decorators. ex. public static final Command getCollectCommand(Intake intake, Serializer serializer) { return Commands.sequence( intake.deployIntake(), Commands.race(intake.runVoltage(), serializer.intake()), intake.retractIntake()); } instead of public static final Command getCollectCommand(Intake intake, Serializer serializer) { return intake.deployIntake() .andThen(Commands.race(intake.runVoltage(), serializer.intake())) .andThen(intake.retractIntake()); } Composite commands reside in their own class called CompositeCommands.java .","title":"Composite Commands"},{"location":"commands-standards/#button-bindings-and-triggers","text":"Commands tell the robot to execute tasks, but in order for the robot code to schedule the command for execution, it needs to be bound to a Trigger . Triggers tell the robot which conditions need to be met to execute commands. Triggers are always instantiated in the configureButtonBindings() method of RobotContainer.java . driver .rightBumper() .and(() -> RobotState.shooterReady(hood, shooter)) .whileTrue( Commands.waitSeconds(0.25) .andThen(CompositeCommands.getShootCommand(intake, serializer, kicker))); in this case, rightBumper() is the trigger representing the right bumper button on the driver's Xbox 360 controller. The .and() call adds another condition to the trigger. The .whileTrue() call means that the robot trigger will only run the command while the conditions of the trigger are met. This trigger made the robot only able to shoot when the driver pressed the right bumper and when the robot code reported the shooter was ready to fire. It is worth noting that Triggers can be arbitrary by creating a new Trigger object and binding it to an event, which can then be passed into a command as a parameter. ex. Trigger arbitraryTrigger = new Trigger(limitSwitch::get) However, this usually isn't necessary because required subsystems get passed into composite commands, meaning there usually isn't a reason to bind command to a trigger unless it's being bound to a button. Arbitrary Triggers are most useful when a condition must be met across a wide number of commands. Trigger shooterReady = new Trigger(() -> RobotState.shooterReady(hood, shooter)) driver .rightBumper() .and(shooterReady) .whileTrue( Commands.waitSeconds(0.25) .andThen(CompositeCommands.getShootCommand(intake, serializer, kicker)));","title":"Button Bindings and Triggers"},{"location":"commands-standards/#autonomous-routines","text":"Autonomous routines are simply composite command that are called during autonomous. Autonomous paths are loaded into the roborio when the code is deployed, and called during the autonomous period. We can follow a path using its path on the roborio. public static final Command centerTwoPiece( Drive drive, Intake intake, Serializer serializer, Kicker kicker, TrackingMode targetType) { return Commands.sequence( AutoBuilder.followPath(PathPlannerPath.fromPathFile(\"deploy/paths/Center to Center Wing Note\")), CompositeCommands.getAimSpeakerCommand(drive), CompositeCommands.getShootCommand(intake, serializer, kicker), CompositeCommands.getTrackNoteSpikeCommand( drive, intake, serializer, AutoPathPoints.NOTE_2, targetType), CompositeCommands.getAimSpeakerCommand(drive), CompositeCommands.getShootCommand(intake, serializer, kicker)); } Ankit notes: - Separate out factories 254 style. - Do we use PathPlanner autos or make the commands in code? PathPlanner autos are visually nicer but can't take arguments","title":"Autonomous Routines"},{"location":"constants-standards/","text":"Constants Standards This section provides standards that govern the constants in robot projects. Naming Conventions and Modifiers All constants follow SNAKE_CASE, and all constants have the modifiers: public static final . Constants.java The official WPIlib constants file houses the different robot types, the tuning mode variable, and the robot loop cycle time. The constants file does not house specific subsystem constants, which are kept in separate constants classes. If there are multiple (>4) constants with a common category, they should be categorized into a subclass. Subsystem Constants Each subsystem requires its own set of constants, however, because the robot code often services more than one robot, these constants can be different depending on the robot the code is running on. Each subsystem will have a constants file in the same directory as the subsystem. Each constant will be declared before it is instantiated, (except for any Tunable Numbers whose values are set after being initialized). Constants will be instantiated in a static block based on which robot is currently running the code. This is done with a switch statement. If a constant is the same across all robots, it is instantiated above the switch statement. package frc.robot.subsystems.serializer; import edu.wpi.first.math.system.plant.DCMotor; import frc.robot.Constants; import frc.robot.util.LoggedTunableNumber; public class SerializerConstants { public static final LoggedTunableNumber SHOOT_VOLTAGE = new LoggedTunableNumber(\"Serializer/Shoot Voltage\"); public static final LoggedTunableNumber INTAKE_VOLTAGE = new LoggedTunableNumber(\"Serializer/Intake Voltage\"); public static final int DEVICE_ID; public static final double SUPPLY_CURRENT_LIMIT; public static final double GEAR_RATIO; public static final double MOMENT_OF_INERTIA; public static final DCMotor MOTOR_CONFIG; public static final int SENSOR_CHANNEL; static { SHOOT_VOLTAGE.initDefault(12.0); INTAKE_VOLTAGE.initDefault(12.0); SUPPLY_CURRENT_LIMIT = 40.0; GEAR_RATIO = 2.0; MOMENT_OF_INERTIA = 0.004; MOTOR_CONFIG = DCMotor.getKrakenX60(1); SENSOR_CHANNEL = 0; switch (Constants.ROBOT) { case SNAPBACK: DEVICE_ID = 3; break; case ROBOT_2K24_TEST: DEVICE_ID = 48; break; case ROBOT_SIM: default: DEVICE_ID = -1; } } }","title":"Constants Standards"},{"location":"constants-standards/#constants-standards","text":"This section provides standards that govern the constants in robot projects.","title":"Constants Standards"},{"location":"constants-standards/#naming-conventions-and-modifiers","text":"All constants follow SNAKE_CASE, and all constants have the modifiers: public static final .","title":"Naming Conventions and Modifiers"},{"location":"constants-standards/#constantsjava","text":"The official WPIlib constants file houses the different robot types, the tuning mode variable, and the robot loop cycle time. The constants file does not house specific subsystem constants, which are kept in separate constants classes. If there are multiple (>4) constants with a common category, they should be categorized into a subclass.","title":"Constants.java"},{"location":"constants-standards/#subsystem-constants","text":"Each subsystem requires its own set of constants, however, because the robot code often services more than one robot, these constants can be different depending on the robot the code is running on. Each subsystem will have a constants file in the same directory as the subsystem. Each constant will be declared before it is instantiated, (except for any Tunable Numbers whose values are set after being initialized). Constants will be instantiated in a static block based on which robot is currently running the code. This is done with a switch statement. If a constant is the same across all robots, it is instantiated above the switch statement. package frc.robot.subsystems.serializer; import edu.wpi.first.math.system.plant.DCMotor; import frc.robot.Constants; import frc.robot.util.LoggedTunableNumber; public class SerializerConstants { public static final LoggedTunableNumber SHOOT_VOLTAGE = new LoggedTunableNumber(\"Serializer/Shoot Voltage\"); public static final LoggedTunableNumber INTAKE_VOLTAGE = new LoggedTunableNumber(\"Serializer/Intake Voltage\"); public static final int DEVICE_ID; public static final double SUPPLY_CURRENT_LIMIT; public static final double GEAR_RATIO; public static final double MOMENT_OF_INERTIA; public static final DCMotor MOTOR_CONFIG; public static final int SENSOR_CHANNEL; static { SHOOT_VOLTAGE.initDefault(12.0); INTAKE_VOLTAGE.initDefault(12.0); SUPPLY_CURRENT_LIMIT = 40.0; GEAR_RATIO = 2.0; MOMENT_OF_INERTIA = 0.004; MOTOR_CONFIG = DCMotor.getKrakenX60(1); SENSOR_CHANNEL = 0; switch (Constants.ROBOT) { case SNAPBACK: DEVICE_ID = 3; break; case ROBOT_2K24_TEST: DEVICE_ID = 48; break; case ROBOT_SIM: default: DEVICE_ID = -1; } } }","title":"Subsystem Constants"},{"location":"control-loop-standards/","text":"Control Loop Standards This section provides standards that govern how control loops are implemented in 1648 robot code. Feedback and PID Control Key Terms: Process variable: The part of the robot being controlled. (ex. Arm position, gyro angle, etc). Setpoint: The desired value of the process variable. Output: The current value of the process variable. Error: setpoint - output, in other words, the difference between where the mechanism is and where it should be. NOTE: ALL EXAMPLE CODE IN THIS DOCUMENT USE WPILIB CLASSES TO IMPLEMENT CONTROL LOOPS. FOR ACTUAL HARDWARE, IT IS PREFERRED TO RUN CONTROL LOOPS ON THE MOTORCONTROLLER. Feedback Control Feedback control is a process by which the robot controls its mechanisms while referencing input data from its sensors. With most mechanisms, the goal is to reach the setpoint as fast and accurately as possible. In other words, it tries to reduce the error to 0. PID controllers The most common form of feedback control is a PID controller . PID controllers consist of 3 gains which influence the behavior of different parts of the mechanism. WPILib has a built in PID Controller class that is used when implementing feedback control. ex. (PID controller to aim the robot at the speaker for FRC 190 2024 robot, Snapback) PIDController aimController = new PIDController(autoAimKP.get(), 0.0, autoAimKD.get(), Constants.LOOP_PERIOD_SECS); aimController.enableContinuousInput(-Math.PI, Math.PI); aimController.setTolerance(Units.degreesToRadians(1.0)); // ... aimController.calculate( measuredGyroAngle.getRadians(), targetGyroAngle.get().getRadians()) The controller calculates the next control output which is used in the calculation of the robot's speed. Feedforward Control In the previous example, the autoAimKI term is 0. The $K_i$ term, or the integral term of a PID controller, corrects for steady state error in the system, which is when the controller can't reach the setpoint. The Integral term scales the output based on the total error over time. Meaning, as time progresses, if the output of the controller doesn't reach the setpoint, the Integral term will eventually rise to a value where the output reaches the setpoint. The Integral term of a PID controller is rarely used because: * It is reactive, meaning it reacts to the steady state error, slowing down the progression of the error to the setpoint. * It is prone to Integral Windup , which is when the mechanism is somehow impeded from reaching the setpoint, which causes the Integral term to rise high enough to cause the output to be too fast. When dealing with steady state error in FRC, most use a Feedforward , which predicts what the steady state error will be based on empircal measurements or theoretical system dynamics. In practice, this often means applying a constant output to a mechanism to overcome the force of gravity or static friction of the system. WPILib has multiple Feedforward classes which are used for implementing Feedforward control. Combining Feedback and Feedforward control When controlling a mechanism, it is often necessary to use both a Feedforward and Feedback controller to account for steady state error like gravity or static friction, while still controlling the mechanism to the setpoint. This is done by simply adding the PID controller output to the feedforward output. leftFeedback = new PIDController(KP.get(), 0.0, KD.get(), Constants.LOOP_PERIOD_SECS); rightFeedback = new PIDController(KP.get(), 0.0, KD.get(), Constants.LOOP_PERIOD_SECS); leftFeedforward = new SimpleMotorFeedforward(KS_LEFT.get(), KV_LEFT.get(), KA_LEFT.get()); rightFeedforward = new SimpleMotorFeedforward(KS_RIGHT.get(), KV_RIGHT.get(), KA_RIGHT.get()); // ... leftFeedback.setSetpoint(leftSetpoint); rightFeedback.setSetpoint(rightSetpoint); io.setLeftVoltage( leftFeedforward.calculate(leftSetpoint) + leftFeedback.calculate(inputs.leftVelocityRadPerSec)); io.setRightVoltage( rightFeedforward.calculate(rightSetpoint)+ rightFeedback.calculate(inputs.rightVelocityRadPerSec)); PID Control with Motion Profiling In FRC, it is often necessary to limit the speed or acceleration of a mechanism. This can be done with a Motion Profile . Motion profiles use a set of parameters, such as max velocity and acceleration to generate a series of setpoints which a controller can follow. This serves to artificially limit the velocity and/or acceleration of a system. WPILib has a ProfiledPIDController class which handles the setpoint generation automatically. ex. (Hood profiled PID controller for FRC 1648 2024 robot, Snapback) ProfiledPIDController profiledFeedback = new ProfiledPIDController( KP.get(), 0.0, KD.get(), new Constraints(MAX_VELOCITY.get(), MAX_ACCELERATION.get())); // ... double position = MathUtil.clamp(positionRad + angleOffset, MIN_POSITION.get(), MAX_POSITION.get()); profiledFeedback.setGoal(position); Standards The standards for control loops are as follows: * All gains should be stored as LoggedTunableNumber objects in the appropriate subsystem's constants file. * ex. (Hood gains for FRC 190 2024 robot, Snapback) java public static final LoggedTunableNumber KP = new LoggedTunableNumber(\"Hood/Kp\"); public static final LoggedTunableNumber KD = new LoggedTunableNumber(\"Hood/Kd\"); public static final LoggedTunableNumber MAX_VELOCITY = new LoggedTunableNumber(\"Hood/Max Velocity\"); public static final LoggedTunableNumber MAX_ACCELERATION = new LoggedTunableNumber(\"Hood/Max Acceleration\"); * Make sure to initialize defaults appropriately . * For actual hardware, all control loops should be run onboard the motorcontroller. See Pheonix 6/Pro documentation for more details. * For simulated hardware, all control loops should use WPILib classes. Tuning Controller Gains Figuring out what the value of each gain should be can be challenging, but with a good tuning process, it can be done methodically. Manual Tuning While tuning controllers manually, it is important to consider the units of the process variable. Consider an example of a single swerve wheel rotation controlled by raw voltage. The unit for the position of the wheel will be radians, and the unit for velocity is radians per second. Swerve wheel rotation works by wrapping the value of the rotation to between (-3.14, 3.14) radians, meaning the maximum error the wheel can experience is 3.14 radians from the setpoint. The maximum voltage the battery can supply a motor is 12 V. Armed with this information, it is plausible to estimate the order of magnitude that $K_p$ and $K_d$ should be. PID Controller Set $K_d$ and $K_i$ to 0. Increase $K_p$ from 0 by small increments until the mechanism starts oscillating around the setpoint. Slowly increase $K_d$ until the robot stops oscillating. NOTES: If the robot is jittery when tuning, reduce $K_d$ If the robot experiences steady state error, consider implementing a Feedforward. A PID controller is tuned well if the output gets to the setpoint quickly without oscillating (green line): PID Controller with Motion Profile Set $K_p$ $K_i$ and $K_d$ to 0. Set the maximum velocity and acceleration for the motion profile very low. Tune the PID controller until the output tracks the setpoint well. Continue this process by incrementing maximum velocity and acceleration and tuning PID until the maximum velocity and acceleration are reasonable. NOTES: A motion profiled PID controller is tuned well when the output \"tracks\" the profile setpoints well. This means that the output should closely follow the shape of the motion profile. SysID Tuning Fortunately, WPILib offers a relatively simple way of empirically measuring what the optimal feedforward gains should be. The SysID tutorial goes over what is needed to perform this task, however there are some standards to mention: SysIDRoutine code should be declared as a member variable of its subsystem: java private final SysIdRoutine sysIdRoutine = new SysIdRoutine( new SysIdRoutine.Config( Volts.of(ShooterConstants.RAMP_RATE_VOLTAGE) .per(Seconds.of(ShooterConstants.RAMP_RATE_SECONDS)), Volts.of(ShooterConstants.STEP_VOLTAGE), Seconds.of(ShooterConstants.SYSID_TIMEOUT), (state) -> Logger.recordOutput(\"Shooter/SysID State\", state.toString())), new SysIdRoutine.Mechanism((volts) -> setVoltage(volts.in(Volts)), null, this)); The command to actually run SysID will be written as a command factory in the subsystem as follows: java public Command runSysId() { return Commands.sequence( sysIdRoutine.quasistatic(Direction.kForward), Commands.waitSeconds(ShooterConstants.SYSID_DELAY), sysIdRoutine.quasistatic(Direction.kReverse), Commands.waitSeconds(ShooterConstants.SYSID_DELAY), sysIdRoutine.dynamic(Direction.kForward), Commands.waitSeconds(ShooterConstants.SYSID_DELAY), sysIdRoutine.dynamic(Direction.kReverse)); } All SysID Commands should be added to the list of autonomous modes if the robot is in Tuning Mode if (Constants.TUNING_MODE) { autoChooser.addOption(\"Shooter SysID\", shooter.runSysId()); autoChooser.addOption( \"Drive Quasistatic Forward\", DriveCommands.runSysIdQuasistatic(drive, Direction.kForward)); autoChooser.addOption( \"Drive Quasistatic Reverse\", DriveCommands.runSysIdQuasistatic(drive, Direction.kReverse)); autoChooser.addOption( \"Drive Dynamic Forward\", DriveCommands.runSysIdDynamic(drive, Direction.kForward)); autoChooser.addOption( \"Drive Dynamic Reverse\", DriveCommands.runSysIdDynamic(drive, Direction.kReverse)); }","title":"Control Loop Standards"},{"location":"control-loop-standards/#control-loop-standards","text":"This section provides standards that govern how control loops are implemented in 1648 robot code.","title":"Control Loop Standards"},{"location":"control-loop-standards/#feedback-and-pid-control","text":"","title":"Feedback and PID Control"},{"location":"control-loop-standards/#key-terms","text":"Process variable: The part of the robot being controlled. (ex. Arm position, gyro angle, etc). Setpoint: The desired value of the process variable. Output: The current value of the process variable. Error: setpoint - output, in other words, the difference between where the mechanism is and where it should be. NOTE: ALL EXAMPLE CODE IN THIS DOCUMENT USE WPILIB CLASSES TO IMPLEMENT CONTROL LOOPS. FOR ACTUAL HARDWARE, IT IS PREFERRED TO RUN CONTROL LOOPS ON THE MOTORCONTROLLER.","title":"Key Terms:"},{"location":"control-loop-standards/#feedback-control","text":"Feedback control is a process by which the robot controls its mechanisms while referencing input data from its sensors. With most mechanisms, the goal is to reach the setpoint as fast and accurately as possible. In other words, it tries to reduce the error to 0.","title":"Feedback Control"},{"location":"control-loop-standards/#pid-controllers","text":"The most common form of feedback control is a PID controller . PID controllers consist of 3 gains which influence the behavior of different parts of the mechanism. WPILib has a built in PID Controller class that is used when implementing feedback control. ex. (PID controller to aim the robot at the speaker for FRC 190 2024 robot, Snapback) PIDController aimController = new PIDController(autoAimKP.get(), 0.0, autoAimKD.get(), Constants.LOOP_PERIOD_SECS); aimController.enableContinuousInput(-Math.PI, Math.PI); aimController.setTolerance(Units.degreesToRadians(1.0)); // ... aimController.calculate( measuredGyroAngle.getRadians(), targetGyroAngle.get().getRadians()) The controller calculates the next control output which is used in the calculation of the robot's speed.","title":"PID controllers"},{"location":"control-loop-standards/#feedforward-control","text":"In the previous example, the autoAimKI term is 0. The $K_i$ term, or the integral term of a PID controller, corrects for steady state error in the system, which is when the controller can't reach the setpoint. The Integral term scales the output based on the total error over time. Meaning, as time progresses, if the output of the controller doesn't reach the setpoint, the Integral term will eventually rise to a value where the output reaches the setpoint. The Integral term of a PID controller is rarely used because: * It is reactive, meaning it reacts to the steady state error, slowing down the progression of the error to the setpoint. * It is prone to Integral Windup , which is when the mechanism is somehow impeded from reaching the setpoint, which causes the Integral term to rise high enough to cause the output to be too fast. When dealing with steady state error in FRC, most use a Feedforward , which predicts what the steady state error will be based on empircal measurements or theoretical system dynamics. In practice, this often means applying a constant output to a mechanism to overcome the force of gravity or static friction of the system. WPILib has multiple Feedforward classes which are used for implementing Feedforward control.","title":"Feedforward Control"},{"location":"control-loop-standards/#combining-feedback-and-feedforward-control","text":"When controlling a mechanism, it is often necessary to use both a Feedforward and Feedback controller to account for steady state error like gravity or static friction, while still controlling the mechanism to the setpoint. This is done by simply adding the PID controller output to the feedforward output. leftFeedback = new PIDController(KP.get(), 0.0, KD.get(), Constants.LOOP_PERIOD_SECS); rightFeedback = new PIDController(KP.get(), 0.0, KD.get(), Constants.LOOP_PERIOD_SECS); leftFeedforward = new SimpleMotorFeedforward(KS_LEFT.get(), KV_LEFT.get(), KA_LEFT.get()); rightFeedforward = new SimpleMotorFeedforward(KS_RIGHT.get(), KV_RIGHT.get(), KA_RIGHT.get()); // ... leftFeedback.setSetpoint(leftSetpoint); rightFeedback.setSetpoint(rightSetpoint); io.setLeftVoltage( leftFeedforward.calculate(leftSetpoint) + leftFeedback.calculate(inputs.leftVelocityRadPerSec)); io.setRightVoltage( rightFeedforward.calculate(rightSetpoint)+ rightFeedback.calculate(inputs.rightVelocityRadPerSec));","title":"Combining Feedback and Feedforward control"},{"location":"control-loop-standards/#pid-control-with-motion-profiling","text":"In FRC, it is often necessary to limit the speed or acceleration of a mechanism. This can be done with a Motion Profile . Motion profiles use a set of parameters, such as max velocity and acceleration to generate a series of setpoints which a controller can follow. This serves to artificially limit the velocity and/or acceleration of a system. WPILib has a ProfiledPIDController class which handles the setpoint generation automatically. ex. (Hood profiled PID controller for FRC 1648 2024 robot, Snapback) ProfiledPIDController profiledFeedback = new ProfiledPIDController( KP.get(), 0.0, KD.get(), new Constraints(MAX_VELOCITY.get(), MAX_ACCELERATION.get())); // ... double position = MathUtil.clamp(positionRad + angleOffset, MIN_POSITION.get(), MAX_POSITION.get()); profiledFeedback.setGoal(position);","title":"PID Control with Motion Profiling"},{"location":"control-loop-standards/#standards","text":"The standards for control loops are as follows: * All gains should be stored as LoggedTunableNumber objects in the appropriate subsystem's constants file. * ex. (Hood gains for FRC 190 2024 robot, Snapback) java public static final LoggedTunableNumber KP = new LoggedTunableNumber(\"Hood/Kp\"); public static final LoggedTunableNumber KD = new LoggedTunableNumber(\"Hood/Kd\"); public static final LoggedTunableNumber MAX_VELOCITY = new LoggedTunableNumber(\"Hood/Max Velocity\"); public static final LoggedTunableNumber MAX_ACCELERATION = new LoggedTunableNumber(\"Hood/Max Acceleration\"); * Make sure to initialize defaults appropriately . * For actual hardware, all control loops should be run onboard the motorcontroller. See Pheonix 6/Pro documentation for more details. * For simulated hardware, all control loops should use WPILib classes.","title":"Standards"},{"location":"control-loop-standards/#tuning-controller-gains","text":"Figuring out what the value of each gain should be can be challenging, but with a good tuning process, it can be done methodically.","title":"Tuning Controller Gains"},{"location":"control-loop-standards/#manual-tuning","text":"While tuning controllers manually, it is important to consider the units of the process variable. Consider an example of a single swerve wheel rotation controlled by raw voltage. The unit for the position of the wheel will be radians, and the unit for velocity is radians per second. Swerve wheel rotation works by wrapping the value of the rotation to between (-3.14, 3.14) radians, meaning the maximum error the wheel can experience is 3.14 radians from the setpoint. The maximum voltage the battery can supply a motor is 12 V. Armed with this information, it is plausible to estimate the order of magnitude that $K_p$ and $K_d$ should be.","title":"Manual Tuning"},{"location":"control-loop-standards/#pid-controller","text":"Set $K_d$ and $K_i$ to 0. Increase $K_p$ from 0 by small increments until the mechanism starts oscillating around the setpoint. Slowly increase $K_d$ until the robot stops oscillating. NOTES: If the robot is jittery when tuning, reduce $K_d$ If the robot experiences steady state error, consider implementing a Feedforward. A PID controller is tuned well if the output gets to the setpoint quickly without oscillating (green line):","title":"PID Controller"},{"location":"control-loop-standards/#pid-controller-with-motion-profile","text":"Set $K_p$ $K_i$ and $K_d$ to 0. Set the maximum velocity and acceleration for the motion profile very low. Tune the PID controller until the output tracks the setpoint well. Continue this process by incrementing maximum velocity and acceleration and tuning PID until the maximum velocity and acceleration are reasonable. NOTES: A motion profiled PID controller is tuned well when the output \"tracks\" the profile setpoints well. This means that the output should closely follow the shape of the motion profile.","title":"PID Controller with Motion Profile"},{"location":"control-loop-standards/#sysid-tuning","text":"Fortunately, WPILib offers a relatively simple way of empirically measuring what the optimal feedforward gains should be. The SysID tutorial goes over what is needed to perform this task, however there are some standards to mention: SysIDRoutine code should be declared as a member variable of its subsystem: java private final SysIdRoutine sysIdRoutine = new SysIdRoutine( new SysIdRoutine.Config( Volts.of(ShooterConstants.RAMP_RATE_VOLTAGE) .per(Seconds.of(ShooterConstants.RAMP_RATE_SECONDS)), Volts.of(ShooterConstants.STEP_VOLTAGE), Seconds.of(ShooterConstants.SYSID_TIMEOUT), (state) -> Logger.recordOutput(\"Shooter/SysID State\", state.toString())), new SysIdRoutine.Mechanism((volts) -> setVoltage(volts.in(Volts)), null, this)); The command to actually run SysID will be written as a command factory in the subsystem as follows: java public Command runSysId() { return Commands.sequence( sysIdRoutine.quasistatic(Direction.kForward), Commands.waitSeconds(ShooterConstants.SYSID_DELAY), sysIdRoutine.quasistatic(Direction.kReverse), Commands.waitSeconds(ShooterConstants.SYSID_DELAY), sysIdRoutine.dynamic(Direction.kForward), Commands.waitSeconds(ShooterConstants.SYSID_DELAY), sysIdRoutine.dynamic(Direction.kReverse)); } All SysID Commands should be added to the list of autonomous modes if the robot is in Tuning Mode if (Constants.TUNING_MODE) { autoChooser.addOption(\"Shooter SysID\", shooter.runSysId()); autoChooser.addOption( \"Drive Quasistatic Forward\", DriveCommands.runSysIdQuasistatic(drive, Direction.kForward)); autoChooser.addOption( \"Drive Quasistatic Reverse\", DriveCommands.runSysIdQuasistatic(drive, Direction.kReverse)); autoChooser.addOption( \"Drive Dynamic Forward\", DriveCommands.runSysIdDynamic(drive, Direction.kForward)); autoChooser.addOption( \"Drive Dynamic Reverse\", DriveCommands.runSysIdDynamic(drive, Direction.kReverse)); }","title":"SysID Tuning"},{"location":"filesystem-standards/","text":"Robot Filesystem frc/ \u2502 \u251c\u2500\u2500 lib/ \u2502 \u251c\u2500\u2500 robot/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 command/ \u2502 \u2502 \u251c\u2500\u2500 auton/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 SomeAutonCommand.java \u2502 \u2502 \u2514\u2500\u2500 SomeCommand.java \u2502 \u251c\u2500\u2500 sensors/ \u2502 \u2502 \u2514\u2500\u2500 some-sensor/ \u2502 \u2502 \u251c\u2500\u2500 SomeSensor.java \u2502 \u2502 \u251c\u2500\u2500 SomeSensorConstants.java \u2502 \u2502 \u251c\u2500\u2500 SomeSensorIO.java \u2502 \u2502 \u251c\u2500\u2500 SomeSensorIOSim.java \u2502 \u2502 \u2514\u2500\u2500 SomeSensorIOType.java \u2502 \u251c\u2500\u2500 subsystems/ \u2502 \u2502 \u2514\u2500\u2500 some-subsystem/ \u2502 \u2502 \u251c\u2500\u2500 some-mechanism/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 SomeMechanismIO.java \u2502 \u2502 \u2502 \u251c\u2500\u2500 SomeMechanismIOSim.java \u2502 \u2502 \u2502 \u2514\u2500\u2500 SomeMechanismIOType.java \u2502 \u2502 \u251c\u2500\u2500 SomeSubsystem.java \u2502 \u2502 \u2514\u2500\u2500 SomeSubsystemConstants.java \u2502 \u251c\u2500\u2500 utils/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 BuildConstants.java \u2502 \u251c\u2500\u2500 Constants.java \u2502 \u251c\u2500\u2500 FieldConstants.java \u2502 \u251c\u2500\u2500 Main.java \u2502 \u251c\u2500\u2500 Robot.java \u2502 \u251c\u2500\u2500 RobotContainer.java \u2502 \u2514\u2500\u2500 RobotState.java Description of Structure frc/ : The root directory for your FRC robot project. lib/ : A directory designated for libraries/files which are not year specific. robot/ : Contains the main code and organization for the robot. command/ : Directory for command classes that control robot actions. auton/ : Subdirectory for autonomous commands. sensors/ : Directory for sensor-related classes and functionality. some-sensor/ : Subdirectory for a specific sensor's implementation. SomeSensor.java : Class representing the sensor's public facing functionality. SomeSensorConstants.java : Contains constant values related to the sensor's operation. SomeSensorIO.java : Input/Output handling class for the sensor. SomeSensorIOSim.java : Simulation version of the sensor's I/O handling. SomeSensorIOType.java : Real version of the sensor's I/O handling. subsystems/ : Directory for subsystem classes that manage various robot mechanisms. some-subsystem/ : Subdirectory for a specific subsystem's implementation. some-mechanism/ : Subdirectory for a particular mechanism within the subsystem. SomeMechanismIO.java : I/O handling class for the mechanism. SomeMechanismIOSim.java : Simulation version of the mechanism's I/O handling. SomeMechanismIOType.java : Real version of the mechanism's I/O handling. SomeSubsystem.java : Class representing the subsystem's public facing functionality. SomeSubsystemConstants.java : Contains constant values related to the subsystem's operation. utils/ : A directory for year-specific utility classes. BuildConstants.java : Class holding build-specific constants. Constants.java : Class containing general constants used throughout the robot code. FieldConstants.java : Class defining constants related to the field and game elements. Main.java : The entry point of the robot code where execution begins. Robot.java : Main class managing the overall robot functionality and lifecycle. RobotContainer.java : Manages the robot's subsystems and command structure, defining how they interact. RobotState.java : Represents the current operational state of the robot.","title":"Filesystem Standards"},{"location":"filesystem-standards/#robot-filesystem","text":"frc/ \u2502 \u251c\u2500\u2500 lib/ \u2502 \u251c\u2500\u2500 robot/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 command/ \u2502 \u2502 \u251c\u2500\u2500 auton/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 SomeAutonCommand.java \u2502 \u2502 \u2514\u2500\u2500 SomeCommand.java \u2502 \u251c\u2500\u2500 sensors/ \u2502 \u2502 \u2514\u2500\u2500 some-sensor/ \u2502 \u2502 \u251c\u2500\u2500 SomeSensor.java \u2502 \u2502 \u251c\u2500\u2500 SomeSensorConstants.java \u2502 \u2502 \u251c\u2500\u2500 SomeSensorIO.java \u2502 \u2502 \u251c\u2500\u2500 SomeSensorIOSim.java \u2502 \u2502 \u2514\u2500\u2500 SomeSensorIOType.java \u2502 \u251c\u2500\u2500 subsystems/ \u2502 \u2502 \u2514\u2500\u2500 some-subsystem/ \u2502 \u2502 \u251c\u2500\u2500 some-mechanism/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 SomeMechanismIO.java \u2502 \u2502 \u2502 \u251c\u2500\u2500 SomeMechanismIOSim.java \u2502 \u2502 \u2502 \u2514\u2500\u2500 SomeMechanismIOType.java \u2502 \u2502 \u251c\u2500\u2500 SomeSubsystem.java \u2502 \u2502 \u2514\u2500\u2500 SomeSubsystemConstants.java \u2502 \u251c\u2500\u2500 utils/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 BuildConstants.java \u2502 \u251c\u2500\u2500 Constants.java \u2502 \u251c\u2500\u2500 FieldConstants.java \u2502 \u251c\u2500\u2500 Main.java \u2502 \u251c\u2500\u2500 Robot.java \u2502 \u251c\u2500\u2500 RobotContainer.java \u2502 \u2514\u2500\u2500 RobotState.java","title":"Robot Filesystem"},{"location":"filesystem-standards/#description-of-structure","text":"frc/ : The root directory for your FRC robot project. lib/ : A directory designated for libraries/files which are not year specific. robot/ : Contains the main code and organization for the robot. command/ : Directory for command classes that control robot actions. auton/ : Subdirectory for autonomous commands. sensors/ : Directory for sensor-related classes and functionality. some-sensor/ : Subdirectory for a specific sensor's implementation. SomeSensor.java : Class representing the sensor's public facing functionality. SomeSensorConstants.java : Contains constant values related to the sensor's operation. SomeSensorIO.java : Input/Output handling class for the sensor. SomeSensorIOSim.java : Simulation version of the sensor's I/O handling. SomeSensorIOType.java : Real version of the sensor's I/O handling. subsystems/ : Directory for subsystem classes that manage various robot mechanisms. some-subsystem/ : Subdirectory for a specific subsystem's implementation. some-mechanism/ : Subdirectory for a particular mechanism within the subsystem. SomeMechanismIO.java : I/O handling class for the mechanism. SomeMechanismIOSim.java : Simulation version of the mechanism's I/O handling. SomeMechanismIOType.java : Real version of the mechanism's I/O handling. SomeSubsystem.java : Class representing the subsystem's public facing functionality. SomeSubsystemConstants.java : Contains constant values related to the subsystem's operation. utils/ : A directory for year-specific utility classes. BuildConstants.java : Class holding build-specific constants. Constants.java : Class containing general constants used throughout the robot code. FieldConstants.java : Class defining constants related to the field and game elements. Main.java : The entry point of the robot code where execution begins. Robot.java : Main class managing the overall robot functionality and lifecycle. RobotContainer.java : Manages the robot's subsystems and command structure, defining how they interact. RobotState.java : Represents the current operational state of the robot.","title":"Description of Structure"},{"location":"global-standards/","text":"Global Standards This section provides standards that govern the setup and maintence of robot code projects. Global Dependencies WPIlib is the framework that teams use to write code for FRC robots. AdvantageKit is a logging framework created by FRC team 6328 which has been released for public use. Gversion is an AdvantageKit dependency that creates the BuildConstants.java file which is important for log replay. Lombok is an annotation based java library that helps reduce boilerplate code by automatically generating getters, setters, etc. Spotless is a code formatter that automatically formats the entire project when compiled. These dependencies should be present in the build.gradle file in each robot project. Objects Naming Conventions Classes and Enumerations should follow PascalCase. Variables should follow camelCase. Member reference variables should begin with m_ . Constants should follow SNAKE_CASE. Directories should follow snake-case. Instantiation Any object that can be instantiated without relying on constructor arguments, (e.g. constants and member variables) should be instantiated at declaration. These objects should be declared and instantiated above any variables that require a constructor for instantiation: ... public class SomeClass { private int someVariable = 0; private SomeOtherClass m_someRobotVariable; public SomeClass(SomeOtherClass someRobotVariable) { this.m_someRobotVariable = someRobotVariable; } ... } Modifiers Member variables should always be private with @Getter / @Setter annotations if they require getters and/or setters. Static variables should always come before non-static variables Constants should always have the public static final modifiers. Default Units 1648 uses these default units for all robot code: Measurement Unit Linear Position Meters Linear Velocity Meters per Second Linear Acceleration Meters per Second Squared Angluar Position Radians Angular Velocity Radians per Second Angular Acceleration Radians per Second Squared Mass Kilograms Moment of Inertia Kilogram Meters Squared Force Netwons Torque/Moment Newton Meters Voltage Volts Current Amps Temperature Fahrenheit","title":"Global Standards"},{"location":"global-standards/#global-standards","text":"This section provides standards that govern the setup and maintence of robot code projects.","title":"Global Standards"},{"location":"global-standards/#global-dependencies","text":"WPIlib is the framework that teams use to write code for FRC robots. AdvantageKit is a logging framework created by FRC team 6328 which has been released for public use. Gversion is an AdvantageKit dependency that creates the BuildConstants.java file which is important for log replay. Lombok is an annotation based java library that helps reduce boilerplate code by automatically generating getters, setters, etc. Spotless is a code formatter that automatically formats the entire project when compiled. These dependencies should be present in the build.gradle file in each robot project.","title":"Global Dependencies"},{"location":"global-standards/#objects","text":"","title":"Objects"},{"location":"global-standards/#naming-conventions","text":"Classes and Enumerations should follow PascalCase. Variables should follow camelCase. Member reference variables should begin with m_ . Constants should follow SNAKE_CASE. Directories should follow snake-case.","title":"Naming Conventions"},{"location":"global-standards/#instantiation","text":"Any object that can be instantiated without relying on constructor arguments, (e.g. constants and member variables) should be instantiated at declaration. These objects should be declared and instantiated above any variables that require a constructor for instantiation: ... public class SomeClass { private int someVariable = 0; private SomeOtherClass m_someRobotVariable; public SomeClass(SomeOtherClass someRobotVariable) { this.m_someRobotVariable = someRobotVariable; } ... }","title":"Instantiation"},{"location":"global-standards/#modifiers","text":"Member variables should always be private with @Getter / @Setter annotations if they require getters and/or setters. Static variables should always come before non-static variables Constants should always have the public static final modifiers.","title":"Modifiers"},{"location":"global-standards/#default-units","text":"1648 uses these default units for all robot code: Measurement Unit Linear Position Meters Linear Velocity Meters per Second Linear Acceleration Meters per Second Squared Angluar Position Radians Angular Velocity Radians per Second Angular Acceleration Radians per Second Squared Mass Kilograms Moment of Inertia Kilogram Meters Squared Force Netwons Torque/Moment Newton Meters Voltage Volts Current Amps Temperature Fahrenheit","title":"Default Units"},{"location":"logging-standards/","text":"Logger Standards This section provides standards that govern the logged outputs and tunable numbers in robot code. Recording Outputs Any values that need to be published over NetworkTables for viewing on Shuffleboard or other WPIlib tools, should be published through the AdvantageKit Logger . Formatting The keys for each recorded output should be: Descriptive Gramatically correct Uppercase Each recorded output has a subsystem associated with it. NetworkTables differentiates values into sections with a / . For each output, before the name of the output's key, goes the subsystem name. ex. Logger.recordOutput(\"Intake/Has Game Piece\", sensor.get()); Tunable Numbers Tunable numbers are the way that 1648 tunes constants without having to re-deploy code. Because tunable numbers are just tunable constants, they should be located in their respective subsystem's constants file. Tunable numbers follow the same formatting guidelines as recorded outputs: ex. public static final LoggedTunableNumber DRIVE_KP = new LoggedTunableNumber(\"Drive/Drive Kp\"); Tunable numbers are then given default values in a static block static { DRIVE_KP.initDefault(0.0); } Tunable numbers can be tuned over NetworkTables when the TUNING_MODE variable in Constants.java is set to true.","title":"Logging Standards"},{"location":"logging-standards/#logger-standards","text":"This section provides standards that govern the logged outputs and tunable numbers in robot code.","title":"Logger Standards"},{"location":"logging-standards/#recording-outputs","text":"Any values that need to be published over NetworkTables for viewing on Shuffleboard or other WPIlib tools, should be published through the AdvantageKit Logger .","title":"Recording Outputs"},{"location":"logging-standards/#formatting","text":"The keys for each recorded output should be: Descriptive Gramatically correct Uppercase Each recorded output has a subsystem associated with it. NetworkTables differentiates values into sections with a / . For each output, before the name of the output's key, goes the subsystem name. ex. Logger.recordOutput(\"Intake/Has Game Piece\", sensor.get());","title":"Formatting"},{"location":"logging-standards/#tunable-numbers","text":"Tunable numbers are the way that 1648 tunes constants without having to re-deploy code. Because tunable numbers are just tunable constants, they should be located in their respective subsystem's constants file. Tunable numbers follow the same formatting guidelines as recorded outputs: ex. public static final LoggedTunableNumber DRIVE_KP = new LoggedTunableNumber(\"Drive/Drive Kp\"); Tunable numbers are then given default values in a static block static { DRIVE_KP.initDefault(0.0); } Tunable numbers can be tuned over NetworkTables when the TUNING_MODE variable in Constants.java is set to true.","title":"Tunable Numbers"},{"location":"robotstate-standards/","text":"Robot State Standards This section provides standards that govern elements of the robot code that pertain to more than one subsystem. The RobotState.java class is used for multiple things: * Pose Estimation * Interpolation Maps * Shot Compensation Constructing RobotState.java One of the purposes of RobotState.java is to combine odometry and vision data to get a more accurate estimated robot pose. This is done by passing suppliers into the RobotState.java constructor: ex. ( RobotState.java constructor from FRC 190 2024 robot, Snapback) public RobotState( Supplier<Rotation2d> robotHeadingSupplier, Supplier<Translation2d> robotFieldRelativeVelocitySupplier, Supplier<SwerveModulePosition[]> modulePositionSupplier, Supplier<CameraType[]> camerasSupplier, Supplier<Pose3d[]> visionPrimaryPosesSupplier, Supplier<Pose3d[]> visionSecondaryPosesSupplier, Supplier<double[]> visionPrimaryPoseTimestampsSupplier, Supplier<double[]> visionSecondaryPoseTimestampsSupplier) { RobotState.robotHeadingSupplier = robotHeadingSupplier; RobotState.robotFieldRelativeVelocitySupplier = robotFieldRelativeVelocitySupplier; RobotState.modulePositionSupplier = modulePositionSupplier; RobotState.camerasSupplier = camerasSupplier; RobotState.visionPrimaryPosesSupplier = visionPrimaryPosesSupplier; RobotState.visionSecondaryPosesSupplier = visionSecondaryPosesSupplier; RobotState.visionPrimaryPoseTimestampsSupplier = visionPrimaryPoseTimestampsSupplier; RobotState.visionSecondaryPoseTimestampsSupplier = visionSecondaryPoseTimestampsSupplier; poseEstimator = new SwerveDrivePoseEstimator( DriveConstants.KINEMATICS, robotHeadingSupplier.get(), modulePositionSupplier.get(), new Pose2d(), DriveConstants.ODOMETRY_STANDARD_DEVIATIONS, VisionConstants.DEFAULT_STANDARD_DEVIATIONS); } The constructor should be called in RobotContainer.java just before the button bindings are configured: // ... // Configure RobotState new RobotState( drive::getRotation, drive::getModulePositions, vision::getCameraTypes, vision::getPrimaryVisionPoses, vision::getSecondaryVisionPoses, vision::getPrimaryPoseTimestamps, vision::getSecondaryPoseTimestamps); // Configure the button bindings configureButtonBindings(); // ... Interpolation Maps and Shot Compensation For shooting games, interpolating hoods and flywheels are very important to dynamically adjust the robot's shot. This is all done in RobotState.java . All interpolation map values are added in a static block: static { // Units: radians per second shooterSpeedMap.put(2.16, 800.0); shooterSpeedMap.put(2.45, 800.0); shooterSpeedMap.put(2.69, 800.0); shooterAngleMap.put(2.84, 800.0); shooterSpeedMap.put(3.19, 800.0); shooterSpeedMap.put(3.52, 800.0); shooterSpeedMap.put(3.85, 900.0); shooterSpeedMap.put(4.29, 900.0); // Units: radians shooterAngleMap.put(2.16, 0.05); shooterAngleMap.put(2.45, 0.05); shooterAngleMap.put(2.69, 0.16); shooterAngleMap.put(2.84, 0.32); shooterAngleMap.put(3.19, 0.39); shooterAngleMap.put(3.52, 0.45); shooterAngleMap.put(3.85, 0.44); shooterAngleMap.put(4.29, 0.45); // Units: seconds timeOfFlightMap.put(2.50, (4.42 - 4.24)); timeOfFlightMap.put(2.75, (2.56 - 2.33)); timeOfFlightMap.put(3.00, (3.43 - 3.18)); timeOfFlightMap.put(3.25, (3.20 - 2.94)); timeOfFlightMap.put(3.50, (2.64 - 2.42)); timeOfFlightMap.put(4.0, (2.60 - 2.32)); } Because of the 1/2\" field tolerance, each FRC field can be different, therefore it is paramount that there be a method for adjusting shots on the fly. @Getter @Setter private static double flywheelOffset = 0.0; @Getter @Setter private static double hoodOffset = 0.0; The variables can then be changed using a Command in CompositeCommands.java : public static Command increaseFlywheelVelocity() { return Commands.runOnce(() -> RobotState.setFlywheelOffset(RobotState.getFlywheelOffset() + 10)); } public static Command decreaseFlywheelVelocity() { return Commands.runOnce(() -> RobotState.setFlywheelOffset(RobotState.getFlywheelOffset() - 10)); } public static Command increaseHoodAngle() { return Commands.runOnce(() -> RobotState.setHoodOffset(RobotState.getHoodOffset() + Units.degreesToRadians(0.25))); } public static Command decreaseHoodAngle() { return Commands.runOnce(() -> RobotState.setHoodOffset(RobotState.getHoodOffset() - Units.degreesToRadians(0.25))); } And bound to a button in RobotContainer.java : operator.y().whileTrue(CompositeCommands.increaseFlywheelVelocity()); operator.a().whileTrue(CompositeCommands.decreaseFlywheelVelocity()); operator.leftBumper().onTrue(CompositeCommands.decreaseHoodAngle()); operator.leftTrigger().onTrue(CompositeCommands.increaseHoodAngle()); Periodic Pose Estimation and ControlData Periodically on the robot, the RobotState.java class takes all the information in from its suppliers, and calculates everything the robot needs to know. For example: * Hood Angle * Flywheel Speed * Effective Aiming Pose (for shooting on the move) This data is calculated, and stored in a record called ControlData : public static record ControlData( Rotation2d robotAngle, double radialVelocity, double shooterSpeed, Rotation2d shooterAngle) {} RobotState.java contains an instance of ControlData as a member variable, which is updated in the periodic method, along with the pose estimator: public static void periodic() { poseEstimator.updateWithTime( Timer.getFPGATimestamp(), robotHeadingSupplier.get(), modulePositionSupplier.get()); for (int i = 0; i < visionPrimaryPosesSupplier.get().length; i++) { poseEstimator.addVisionMeasurement( visionPrimaryPosesSupplier.get()[i].toPose2d(), visionPrimaryPoseTimestampsSupplier.get()[i], camerasSupplier.get()[i].primaryStandardDeviations); } if (!secondaryPosesNullAlert.isActive()) { try { for (int i = 0; i < visionSecondaryPosesSupplier.get().length; i++) { poseEstimator.addVisionMeasurement( visionSecondaryPosesSupplier.get()[i].toPose2d(), visionSecondaryPoseTimestampsSupplier.get()[i], camerasSupplier.get()[i].secondaryStandardDeviations); } secondaryPosesNullAlert.set(false); } catch (Exception e) { secondaryPosesNullAlert.set(true); } } Translation2d speakerPose = AllianceFlipUtil.apply(FieldConstants.Speaker.centerSpeakerOpening.toTranslation2d()); double distanceToSpeaker = poseEstimator.getEstimatedPosition().getTranslation().getDistance(speakerPose); Translation2d effectiveAimingPose = poseEstimator .getEstimatedPosition() .getTranslation() .plus( robotFieldRelativeVelocitySupplier .get() .times(timeOfFlightMap.get(distanceToSpeaker))); double effectiveDistanceToSpeaker = effectiveAimingPose.getDistance(speakerPose); Rotation2d setpointAngle = speakerPose.minus(effectiveAimingPose).getAngle(); double tangentialVelocity = -robotFieldRelativeVelocitySupplier.get().rotateBy(setpointAngle.unaryMinus()).getY(); double radialVelocity = tangentialVelocity / effectiveDistanceToSpeaker; controlData = new ControlData( setpointAngle, radialVelocity, shooterSpeedMap.get(effectiveDistanceToSpeaker), new Rotation2d(shooterAngleMap.get(effectiveDistanceToSpeaker))); Logger.recordOutput(\"RobotState/Primary Poses\", visionPrimaryPosesSupplier.get()); Logger.recordOutput(\"RobotState/Secondary Pose\", visionSecondaryPosesSupplier.get()); Logger.recordOutput(\"RobotState/Estimated Pose\", poseEstimator.getEstimatedPosition()); Logger.recordOutput(\"RobotState/ControlData/Robot Angle Setpoint\", setpointAngle); Logger.recordOutput( \"RobotState/ControlData/Effective Distance to Speaker\", effectiveDistanceToSpeaker); Logger.recordOutput( \"RobotState/ControlData/Effective Aiming Pose\", new Pose2d(effectiveAimingPose, new Rotation2d())); }","title":"RobotState Standards"},{"location":"robotstate-standards/#robot-state-standards","text":"This section provides standards that govern elements of the robot code that pertain to more than one subsystem. The RobotState.java class is used for multiple things: * Pose Estimation * Interpolation Maps * Shot Compensation","title":"Robot State Standards"},{"location":"robotstate-standards/#constructing-robotstatejava","text":"One of the purposes of RobotState.java is to combine odometry and vision data to get a more accurate estimated robot pose. This is done by passing suppliers into the RobotState.java constructor: ex. ( RobotState.java constructor from FRC 190 2024 robot, Snapback) public RobotState( Supplier<Rotation2d> robotHeadingSupplier, Supplier<Translation2d> robotFieldRelativeVelocitySupplier, Supplier<SwerveModulePosition[]> modulePositionSupplier, Supplier<CameraType[]> camerasSupplier, Supplier<Pose3d[]> visionPrimaryPosesSupplier, Supplier<Pose3d[]> visionSecondaryPosesSupplier, Supplier<double[]> visionPrimaryPoseTimestampsSupplier, Supplier<double[]> visionSecondaryPoseTimestampsSupplier) { RobotState.robotHeadingSupplier = robotHeadingSupplier; RobotState.robotFieldRelativeVelocitySupplier = robotFieldRelativeVelocitySupplier; RobotState.modulePositionSupplier = modulePositionSupplier; RobotState.camerasSupplier = camerasSupplier; RobotState.visionPrimaryPosesSupplier = visionPrimaryPosesSupplier; RobotState.visionSecondaryPosesSupplier = visionSecondaryPosesSupplier; RobotState.visionPrimaryPoseTimestampsSupplier = visionPrimaryPoseTimestampsSupplier; RobotState.visionSecondaryPoseTimestampsSupplier = visionSecondaryPoseTimestampsSupplier; poseEstimator = new SwerveDrivePoseEstimator( DriveConstants.KINEMATICS, robotHeadingSupplier.get(), modulePositionSupplier.get(), new Pose2d(), DriveConstants.ODOMETRY_STANDARD_DEVIATIONS, VisionConstants.DEFAULT_STANDARD_DEVIATIONS); } The constructor should be called in RobotContainer.java just before the button bindings are configured: // ... // Configure RobotState new RobotState( drive::getRotation, drive::getModulePositions, vision::getCameraTypes, vision::getPrimaryVisionPoses, vision::getSecondaryVisionPoses, vision::getPrimaryPoseTimestamps, vision::getSecondaryPoseTimestamps); // Configure the button bindings configureButtonBindings(); // ...","title":"Constructing RobotState.java"},{"location":"robotstate-standards/#interpolation-maps-and-shot-compensation","text":"For shooting games, interpolating hoods and flywheels are very important to dynamically adjust the robot's shot. This is all done in RobotState.java . All interpolation map values are added in a static block: static { // Units: radians per second shooterSpeedMap.put(2.16, 800.0); shooterSpeedMap.put(2.45, 800.0); shooterSpeedMap.put(2.69, 800.0); shooterAngleMap.put(2.84, 800.0); shooterSpeedMap.put(3.19, 800.0); shooterSpeedMap.put(3.52, 800.0); shooterSpeedMap.put(3.85, 900.0); shooterSpeedMap.put(4.29, 900.0); // Units: radians shooterAngleMap.put(2.16, 0.05); shooterAngleMap.put(2.45, 0.05); shooterAngleMap.put(2.69, 0.16); shooterAngleMap.put(2.84, 0.32); shooterAngleMap.put(3.19, 0.39); shooterAngleMap.put(3.52, 0.45); shooterAngleMap.put(3.85, 0.44); shooterAngleMap.put(4.29, 0.45); // Units: seconds timeOfFlightMap.put(2.50, (4.42 - 4.24)); timeOfFlightMap.put(2.75, (2.56 - 2.33)); timeOfFlightMap.put(3.00, (3.43 - 3.18)); timeOfFlightMap.put(3.25, (3.20 - 2.94)); timeOfFlightMap.put(3.50, (2.64 - 2.42)); timeOfFlightMap.put(4.0, (2.60 - 2.32)); } Because of the 1/2\" field tolerance, each FRC field can be different, therefore it is paramount that there be a method for adjusting shots on the fly. @Getter @Setter private static double flywheelOffset = 0.0; @Getter @Setter private static double hoodOffset = 0.0; The variables can then be changed using a Command in CompositeCommands.java : public static Command increaseFlywheelVelocity() { return Commands.runOnce(() -> RobotState.setFlywheelOffset(RobotState.getFlywheelOffset() + 10)); } public static Command decreaseFlywheelVelocity() { return Commands.runOnce(() -> RobotState.setFlywheelOffset(RobotState.getFlywheelOffset() - 10)); } public static Command increaseHoodAngle() { return Commands.runOnce(() -> RobotState.setHoodOffset(RobotState.getHoodOffset() + Units.degreesToRadians(0.25))); } public static Command decreaseHoodAngle() { return Commands.runOnce(() -> RobotState.setHoodOffset(RobotState.getHoodOffset() - Units.degreesToRadians(0.25))); } And bound to a button in RobotContainer.java : operator.y().whileTrue(CompositeCommands.increaseFlywheelVelocity()); operator.a().whileTrue(CompositeCommands.decreaseFlywheelVelocity()); operator.leftBumper().onTrue(CompositeCommands.decreaseHoodAngle()); operator.leftTrigger().onTrue(CompositeCommands.increaseHoodAngle());","title":"Interpolation Maps and Shot Compensation"},{"location":"robotstate-standards/#periodic-pose-estimation-and-controldata","text":"Periodically on the robot, the RobotState.java class takes all the information in from its suppliers, and calculates everything the robot needs to know. For example: * Hood Angle * Flywheel Speed * Effective Aiming Pose (for shooting on the move) This data is calculated, and stored in a record called ControlData : public static record ControlData( Rotation2d robotAngle, double radialVelocity, double shooterSpeed, Rotation2d shooterAngle) {} RobotState.java contains an instance of ControlData as a member variable, which is updated in the periodic method, along with the pose estimator: public static void periodic() { poseEstimator.updateWithTime( Timer.getFPGATimestamp(), robotHeadingSupplier.get(), modulePositionSupplier.get()); for (int i = 0; i < visionPrimaryPosesSupplier.get().length; i++) { poseEstimator.addVisionMeasurement( visionPrimaryPosesSupplier.get()[i].toPose2d(), visionPrimaryPoseTimestampsSupplier.get()[i], camerasSupplier.get()[i].primaryStandardDeviations); } if (!secondaryPosesNullAlert.isActive()) { try { for (int i = 0; i < visionSecondaryPosesSupplier.get().length; i++) { poseEstimator.addVisionMeasurement( visionSecondaryPosesSupplier.get()[i].toPose2d(), visionSecondaryPoseTimestampsSupplier.get()[i], camerasSupplier.get()[i].secondaryStandardDeviations); } secondaryPosesNullAlert.set(false); } catch (Exception e) { secondaryPosesNullAlert.set(true); } } Translation2d speakerPose = AllianceFlipUtil.apply(FieldConstants.Speaker.centerSpeakerOpening.toTranslation2d()); double distanceToSpeaker = poseEstimator.getEstimatedPosition().getTranslation().getDistance(speakerPose); Translation2d effectiveAimingPose = poseEstimator .getEstimatedPosition() .getTranslation() .plus( robotFieldRelativeVelocitySupplier .get() .times(timeOfFlightMap.get(distanceToSpeaker))); double effectiveDistanceToSpeaker = effectiveAimingPose.getDistance(speakerPose); Rotation2d setpointAngle = speakerPose.minus(effectiveAimingPose).getAngle(); double tangentialVelocity = -robotFieldRelativeVelocitySupplier.get().rotateBy(setpointAngle.unaryMinus()).getY(); double radialVelocity = tangentialVelocity / effectiveDistanceToSpeaker; controlData = new ControlData( setpointAngle, radialVelocity, shooterSpeedMap.get(effectiveDistanceToSpeaker), new Rotation2d(shooterAngleMap.get(effectiveDistanceToSpeaker))); Logger.recordOutput(\"RobotState/Primary Poses\", visionPrimaryPosesSupplier.get()); Logger.recordOutput(\"RobotState/Secondary Pose\", visionSecondaryPosesSupplier.get()); Logger.recordOutput(\"RobotState/Estimated Pose\", poseEstimator.getEstimatedPosition()); Logger.recordOutput(\"RobotState/ControlData/Robot Angle Setpoint\", setpointAngle); Logger.recordOutput( \"RobotState/ControlData/Effective Distance to Speaker\", effectiveDistanceToSpeaker); Logger.recordOutput( \"RobotState/ControlData/Effective Aiming Pose\", new Pose2d(effectiveAimingPose, new Rotation2d())); }","title":"Periodic Pose Estimation and ControlData"},{"location":"subsystem-standards/","text":"Subsystem Standards This section provides standards that govern how subsystems are written and maintained. Subsystems Overview Subsystems are how FRC teams split up the logic for the different parts of the robots. Each subsystem must: Extend SubsystemBase . Not include any constants . Override the periodic() method. Subsystem logic. Update IO implementation with inputs - this must come before processing the inputs. Process the subsystem inputs. Update the mechanism widget. Update any tunable numbers . Update any Real Outputs Contain all logic for that subsystem. package frc.robot.subsystems.accelerator; import edu.wpi.first.wpilibj2.command.Command; import edu.wpi.first.wpilibj2.command.SubsystemBase; import org.littletonrobotics.junction.Logger; public class Accelerator extends SubsystemBase { private final AcceleratorIOInputsAutoLogged inputs = new AcceleratorIOInputsAutoLogged(); private final AcceleratorIO io; public Accelerator(AcceleratorIO io) { this.io = io; } @Override public void periodic() { io.updateInputs(inputs); Logger.processInputs(\"Accelerator\", inputs); } private void stop() { io.setVoltage(0.0); } }","title":"Subsystem Standards"},{"location":"subsystem-standards/#subsystem-standards","text":"This section provides standards that govern how subsystems are written and maintained.","title":"Subsystem Standards"},{"location":"subsystem-standards/#subsystems-overview","text":"Subsystems are how FRC teams split up the logic for the different parts of the robots. Each subsystem must: Extend SubsystemBase . Not include any constants . Override the periodic() method. Subsystem logic. Update IO implementation with inputs - this must come before processing the inputs. Process the subsystem inputs. Update the mechanism widget. Update any tunable numbers . Update any Real Outputs Contain all logic for that subsystem. package frc.robot.subsystems.accelerator; import edu.wpi.first.wpilibj2.command.Command; import edu.wpi.first.wpilibj2.command.SubsystemBase; import org.littletonrobotics.junction.Logger; public class Accelerator extends SubsystemBase { private final AcceleratorIOInputsAutoLogged inputs = new AcceleratorIOInputsAutoLogged(); private final AcceleratorIO io; public Accelerator(AcceleratorIO io) { this.io = io; } @Override public void periodic() { io.updateInputs(inputs); Logger.processInputs(\"Accelerator\", inputs); } private void stop() { io.setVoltage(0.0); } }","title":"Subsystems Overview"}]}